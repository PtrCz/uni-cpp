import pathlib

def table_to_cpp_src(table: list, name: str, value_type_name: str) -> str:

    table_size = len(table)

    result = f'constexpr std::array<{value_type_name}, {table_size}> {name}{{'

    for value in table:
        if isinstance(value, int):
            cpp_value = f'{value:#04X}'.replace('0X', '0x')
        else:
            cpp_value = str(value)

        result += cpp_value + ','

    if len(table) != 0:
        result = result[:-1] # remove the last comma

    result += '};\n\n'

    return result

def generated_table_to_cpp_src(table_name: str, property_type_name: str, generated_lookup_tables: dict) -> str:
    """
    Converts a table from the multistage-lookup-table to a C++ array variable definition.
    """

    stage2_holds_prop_values_inplace = generated_lookup_tables['format']['stage2_holds_prop_values_inplace']

    table_holds_properties = table_name == 'stage3' or (table_name == 'stage2' and stage2_holds_prop_values_inplace)

    if table_holds_properties:
        value_type_name = property_type_name

    else:
        value_type_name = 'std::uint' + str(generated_lookup_tables['format'][table_name + '_value_type_size'] * 8) + '_t'

    return table_to_cpp_src(generated_lookup_tables[table_name], table_name, value_type_name)


def generate_lookup_function(property_type_name: str, generated_lookup_tables: dict) -> str:
    """
    Generates a C++ lookup function for the given tables. The generated function uses the default lookup algorithm.

    The result of this (python) function changes depending on the used optimizations and block size of the multistage-lookup-table provided.
    """

    block_size = generated_lookup_tables['block_size']

    stage1_needs_extra_lookup = generated_lookup_tables['format']['stage1_needs_extra_lookup']

    stage2_holds_prop_values_inplace = generated_lookup_tables['format']['stage2_holds_prop_values_inplace']

    result = \
f"""[[nodiscard]] constexpr {property_type_name} lookup(const std::uint32_t code_point) noexcept
{{
    // See `dev/docs/multistage-lookup-tables.md`.

    const std::uint32_t quot = code_point / {block_size};
    const std::uint32_t rem  = code_point % {block_size};
"""
    
    if stage1_needs_extra_lookup:
        result += \
f"""
    const std::uint32_t stage2_offset = stage2_offsets[stage1[quot]];
"""
    else:
        result += \
f"""
    const std::uint32_t stage2_offset = stage1[quot];
"""
        
    if stage2_holds_prop_values_inplace:
        result += \
f"""
    return stage2[stage2_offset + rem];
"""
    else:
        result += \
f"""
    const auto stage2_value = stage2[stage2_offset + rem];
    return stage3[stage2_value];
"""

    result += '}\n\n'
    return result


def generate_cpp_file(
    unicode_version: str,
    filepath: str,
    namespace_name: str,
    property_type_name: str,
    generated_lookup_tables: dict,
    extra_contents: str | None = None
) -> None:
    """
    Generates a C++ file storing the multistage-lookup-tables and the `lookup` function in the specified namespace.

    **Note:** The generated file has **terrible** formatting. Please use clang-format.

    Args:
        filepath (str): The path to the output file.
        namespace_name (str): The last part of the namespace that has the data and the `lookup` function.
                              For `xyz` the data would be in the `upp::impl::unicode_data::xyz` namespace.
        property_type_name (str): The name of the C++ type that stores the properties of a single code point.
        extra_contents (str | None): Optional contents to include in the file after the table definitions.
                                     The contents **are** in the namespace, but **aren't** in an export block.
                                     Defaults to None.
    """

    pathlib.Path(filepath).parent.mkdir(parents = True, exist_ok = True)
    filename = pathlib.Path(filepath).stem

    lookup_function = generate_lookup_function(property_type_name, generated_lookup_tables)

    with open(filepath, 'w', encoding='utf-8') as file:

        # File beginning
        file.write(
f"""// DO NOT EDIT THIS FILE! THIS FILE WAS GENERATED BY `dev/tools/unicode_data_generator`.
// Unicode version: {unicode_version}

export module uni_cpp.impl.unicode_data:{filename};

export import std;

namespace upp::impl::unicode_data::{namespace_name}
{{
"""
        )

        file.write(generated_table_to_cpp_src('stage1', property_type_name, generated_lookup_tables))

        if generated_lookup_tables['format']['stage1_needs_extra_lookup']:
            file.write(generated_table_to_cpp_src('stage2_offsets', property_type_name, generated_lookup_tables))

        file.write(generated_table_to_cpp_src('stage2', property_type_name, generated_lookup_tables))

        if not generated_lookup_tables['format']['stage2_holds_prop_values_inplace']:
            file.write(generated_table_to_cpp_src('stage3', property_type_name, generated_lookup_tables))

        if extra_contents is not None:
            file.write(extra_contents)

        file.write(lookup_function)

        file.write('}') # close the namespace